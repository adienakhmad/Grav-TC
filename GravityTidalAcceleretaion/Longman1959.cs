/*
 * GravTC Longman1959 -- Compute variations in g due to lunar/solar to be used in gravity measured data.
 * 
 * User gives datetime, position in latitude, longitude, elevation and time zone information
 * Output is a TidalCorrection object which consist of datetime, position, lunar component, solar component and total correction.
 * g is calculated in mGal units
 * 
 * This class is ported to C# from C code written by Tom Van Baak (tvb) www.LeapSecond.com/tools in 2004.
 * See his and the original author comments below.
 * 
 * This class is used to calculate gravity survey correction due to the effect of vertical upward by the sun and moon.
 * 
 * 02-Sept-2017 Adien Akhmad M
 * Department of Geophysics
 * Universitas Gadjah Mada
 * 
 */

// From http://www.LeapSecond.com/toolstides.c
//
// tides -- Compute variations in g due to lunar/solar tides.
//
// - User gives lat/lon of position.
// - Output is a table of variations in little g by date/time.
// - Both MJD (UTC) and Excel (local) dates are displayed.
// - g is reported in uGal units (micro-gals).
// - Lunar-only and Solar-only components are also displayed.
//
// Math calculation converted to C from QBASIC code found on
// the web. See author's original comments below.
//
// This program is used to better understand the performance
// of an ultra-precise free pendulum clock, which ultimately,
// if all mechanical and environmental effects were eliminated,
// is simply a gravimeter disguised as a clock.
//
// 09-Nov-2004 Tom Van Baak (tvb) www.LeapSecond.com/tools
//

/*
 * From http://geophysics.ou.edu/gravmag/reduce/tide-acd.txt

'  TIDE-ACD.BAS
'
'       Copyright, 1993, J. L. Ahern
'
'  Calculates the acceleration due to the sun and moon at a given location,
'    for every hour, beginning at a specified hour, day, month and year.
'    Value calculated is the UPWARD pull due to the sun and moon. To use
'    as correction to measured gravity data, you would need to ADD these
'    numbers, not subtract them.  When the moon is overhead, for example
'    this program predicts a relatively large positive number, indicating
'    a large upward pull due to the moon. This would result in a DECREASE
'    in a gravity meter reading. Thus the tide value would be ADDED to
'    correct for this effect.
'
'    Based on equations presented by
'
'       Schureman, P., A manual of the harmonic analysis and prediction of
'         tides. U.S. Coast and Geodetic Survey, Spec. Pub. 98, 1924 (revised
'         in 1941 and 1958).
'
'  and collected by
'
'       Longman, I. M., Formulas for computing the tidal acceleration due to
'         the moon and the sun. J. Geophys. Res., 64, 2351-2355, 1959.
'
'  Love numbers from Stacey, Physics of the Earth.
'

From http://scienceworld.wolfram.com/physics/LoveNumber.html

    h is the ratio of the height of a body tide to the static
    marine tide (introduced by A. E. H. Love). k is ratio of
    additional potential produced by the redistribution of mass
    to the deforming potential (introduced by A. E. H. Love).
    l is the ratio of horizontal displacement of the crust to
    that of the equilibrium fluid tide (introduced by T. Shida).

From http://physics.ucsd.edu/~tmurphy/apollo/doc/tides.pdf

    The real earth does not have time to arrive at equilibrium
    with respect to the W2 tidal potential it rotates underneath.
    As such, an additional Love number, h, describes how much
    deflection the earth body experiences relative to that which
    would be expected directly from the perturbing potential.
    Empirically, the h, k, and l Love numbers are seen to be:
        h = 0.612,
        k = 0.303,
        l = 0.04.
    The definitions of these numbers are somewhat slippery, so I
    offer here my best interpretation of whatthese numbers mean.

    h describes the height (radial) displacement attained by the
    (solid) surface relative to what would have been attained by
    a perfectly fluid body in response to the perturbing force,
    neglecting the additional potential generated by the
    redistribution of matter. Therefore a perfectly fluid body
    in tidal equilibrium has h = 1+k (see below). The value
    h = 0.612 is presumably for the solid earth, with a value
    nearer unity for the oceans.

    k is the ratio of the potential contributed by the tidally
    deformed body to that of the perturbing potential (i.e., W2).
    A rigid body has k = 0 because there is no redistribution
    of matter. A uniform density fluid body has k = 3/2, and a
    fluid body with the earth's density profile has k = 0.94.
    The observed earth tidal response has k = 0.303 for the
    solid earth, and k = 0.245 for the earth-plus-oceans.
    I assume these are lower than the equilibrium value of 0.94
    because only the low-density exterior of the earth responds
    to the transient tidal disturbance.
 */

using System;

namespace GravityTidalCorrection
{
    public static class Longman1959
    {
        /// <summary>
        /// Newton's gravitational constant
        /// </summary>
        private const double Mu = 6.67e-08;

        /// <summary>
        /// Mass of the moon in grams
        /// </summary>
        private const double M = 7.3537e+25;

        /// <summary>
        /// Mass of the sun in grams
        /// </summary>
        private const double S = 1.993e+33;

        /// <summary>
        /// Ratio of mean motion of the sun to that of the moon
        /// </summary>
        private const double Ml = 0.074804;

        /// <summary>
        /// Eccentricity of the moon's orbit
        /// </summary>
        private const double El = 0.0549;

        /// <summary>
        /// Mean distance between centers of the earth and sun in cm
        /// </summary>
        private const double Cl1 = 1.495e+13;

        /// <summary>
        /// Mean distance between the centers of the earth and the moon
        /// </summary>
        private const double Cl = 3.84402e+10;

        /*
        /// <summary>
        /// Earth's equitorial radius in cm
        /// </summary>
        const double Al = 6.37827e+08;

        /// <summary>
        /// Inclination of the moon's orbit to the ecliptic
        /// </summary>
        const double Il = 0.08979719;

        /// <summary>
        /// Equal to radians(23.452), Inclination of the Earth's equator to the ecliptic 23.452 degrees
        /// </summary>
        const double Omega = 0.4093146162;
        */

        // Love Numbers
        private const double H2 = 0.612;

        private const double K2 = 0.303;

        private static double MjdToExcel(double n) => n - 15018.0;
        private static double FmjdToJ1900(double n) => n - 15019.5;

        // shortcut to polynomial function
        private static double Poly(double t, double a, double b, double c, double d)
        {
            return a + (b * t) + (c * Math.Pow(t, 2)) + (d * Math.Pow(t, 3));
        }

        private static double Radian(double x) => x / 180.0 * Math.PI;
        private static double Sq2(double x) => Math.Pow(x, 2);
        private static double Sq3(double x) => Math.Pow(x, 3);
        private static double Sq4(double x) => Math.Pow(x, 4);

        private static double Utc2ModifiedJulian(DateTime utcDate)
        {
            double hour = utcDate.Hour;
            double minute = utcDate.Minute;
            double second = utcDate.Second;

            var day = utcDate.Day;
            var month = utcDate.Month;
            var year = utcDate.Year;

            if (month < 3)
            {
                month += 12;
            }
            if (month > 12)
            {
                year -= 1;
            }
            if (month > 13)
            {
                day += 1;
            }

            var fmjd = (year * 365) + (year / 4) - (year / 100) + (year / 400) + (489 * month) / 16 + day - 678973;
            var result = fmjd + ((hour * 60.0 + minute) * 60.0 + second) / 86400.0;

            return result;
        }

        /// <summary>
        /// Compute the upward tidal acceleration due to sun and moon at the given time and location.
        /// </summary>
        /// <param name="date">Date and time, user defined timezone</param>
        /// <param name="tzSource">Timezone of the datetime</param>
        /// <param name="lat">Latitude, decimal degree, N+ S-</param>
        /// <param name="lon">Longitude, decimal degree E+ W-</param>
        /// <param name="alt">Altitude, in meters</param>
        /// <returns></returns>
        public static TidalRecord Compute(DateTime date, TimeZoneInfo tzSource, double lat, double lon, double alt)
        {
            // TODO: Improve code clarity, explain all the variable compared to the original paper
            var dateInUtc = TimeZoneInfo.ConvertTime(date, tzSource, TimeZoneInfo.Utc);
            var tz = tzSource.BaseUtcOffset.TotalHours;
            var fmjd = Utc2ModifiedJulian(dateInUtc);


            var tl0 = (fmjd % 1.0) * 24.0;
            var j1900 = FmjdToJ1900(fmjd);

            var t = j1900 / 36525;

            // Longitude of the moon's ascending node in its orbit reckoned from the referred equinox
            var n = Poly(t, 4.523601612, -33.75715303, 0.0000367488, 0.0000000387);

            // Eccentricity of the Earth's orbit
            var el1 = Poly(t, 0.01675104, -0.0000418, 0.000000126, 0);

            // Mean longitude of moon in its orbit reckoned from the referred equinox
            var sl = Poly(t, 4.720023438, 8399.7093, 0.0000440695, 0.0000000329);

            // Mean longitude of lunar perigee
            var pl = Poly(t, 5.835124721, 71.01800936, -0.0001805446, -0.0000002181);

            // Mean longitude of the sun
            var hl = Poly(t, 4.881627934, 628.3319508, 0.0000052796, 0);

            // Mean longitude of solar perigee
            var pl1 = Poly(t, 4.908229467, 0.0300052641, 7.9024e-06, 0.0000000581);

            // Inclination of the moon's orbit to the equator
            var i = Math.Acos(0.9136975738 - 0.0356895353 * Math.Cos(n));

            //Longitude in the celestial equator of its intersection A with the moon's orbit
            var nu = Math.Asin(0.0896765581 * Math.Sin(n) / Math.Sin(i));

            // (tl) Hour angle of mean sun measured west-ward from the place of observations
            var tl = Radian(15 * (tl0 - 12) + lon);

            // right ascension of meridian of place of observations reckoned from A
            var chi = tl + hl - nu;

            // right ascension of meridian of place of observations reckoned from the vernal equinox
            var chi1 = tl + hl;

            // Longitude of sun in the ecliptic reckoned from the vernal equinox
            var ll1 = hl + 2 * el1 * Math.Sin(hl - pl1);

            // cos(alpha) where alpha is defined in eq. 15 and 16
            var cosalf = Math.Cos(n) * Math.Cos(nu) + Math.Sin(n) * Math.Sin(nu) * 0.9173938078;

            // sin(alpha) where alpha is defined in eq. 15 and 16
            var sinalf = 0.3979806546 * Math.Sin(n) / Math.Sin(i); // 0.3979806546 = sin omega

            // (alpha) alpha is defined in eq. 15 and 16
            var alf = 2 * Math.Atan(sinalf / (1 + cosalf));

            // Longitude in the moon's orbit of its ascending intersection with the celestial equator
            var xi = n - alf;

            // Mean longitude of moon in radians in its orbit reckoned from A
            var sigma = sl - xi;

            // Longitude of moon in its orbit reckoned from its ascending intersection with the equator
            // l = sigma + 2*e*sin(s-p)+(5./4)*e*e*sin(2*(s-p)) + (15./4)*m*e*sin(s-2*h+p) + (11./8)*m*m*sin(2*(s-h))
            // constant is used to accelerate computation
            var ll = sigma + 0.1098 * Math.Sin(sl - pl)
                     + 0.0037675125 * Math.Sin(2 * (sl - pl))
                     + 0.0154002735 * Math.Sin(sl - 2 * hl + pl)
                     + 0.0076940028 * Math.Sin(2 * (sl - hl));

            // Latitude of point P
            var lm = Radian(lat);

            // cosine(theta) Theta represents the zenith angle of the moon
            var costht = Math.Sin(lm) * Math.Sin(i) * Math.Sin(ll) + Math.Cos(lm) *
                         (Sq2(Math.Cos(0.5 * i)) * Math.Cos(ll - chi) + Sq2(Math.Sin(0.5 * i)) * Math.Cos(ll + chi));

            // cosine(phi) Phi represents the zenith angle of the run
            var cosphi = Math.Sin(lm) * 0.3979806546 * Math.Sin(ll1) + Math.Cos(lm) *
                         (0.9586969039 * Math.Cos(ll1 - chi1) + 0.0413030961 * Math.Cos(ll1 + chi1));


            // Distance parameter, equation 34
            var c = 1 / Math.Sqrt(1 + 0.006738 * Sq2(Math.Sin(lm)));

            // Distance from point P to the center of the Earth
            // 6.37827e+08 = earth equatorial radius
            var rl = 6.37827e+08 * c + alt * 100.0; // convert alt from meters to cm

            // Distance parameter, equation 31
            const double ap = 2.60930776e-11;

            // Distance parameter, equation 31
            var ap1 = 1 / (1.495e+13 * (1 - el1 * el1));

            // Distance between centers of the Earth and the moon
            var dl = 1 / (1 / Cl
                          + ap * El * Math.Cos(sl - pl)
                          + ap * El * El * Math.Cos(2 * (sl - pl))
                          + 1.875 * ap * Ml * El * Math.Cos(sl - 2 * hl + pl)
                          + ap * Ml * Ml * Math.Cos(2 * (sl - hl)));

            // Distance between centers of the Earth and the sun
            var d = 1 / (1 / Cl1
                         + ap1 * el1 * Math.Cos(hl - pl1));

            // Vertical componet of tidal acceleration due to the moon
            var gm = Mu * M * rl * (3 * Sq2(costht) - 1) / Sq3(dl)
                     + 1.5 * Mu * M * rl * rl * (5 * Sq3(costht) - 3 * costht) / Sq4(dl);

            // Vertical componet of tidal acceleration due to the sun
            var gs = Mu * S * rl * (3 * Sq2(cosphi) - 1) / Sq3(d);

            const double love = (1 + H2 - 1.5 * K2);
            var g0 = (gm + gs) * love;
            
            // in mGal
            var tidalAcceleration = new TidalRecord(DateTime.FromOADate(MjdToExcel(fmjd) + (tz / 24.0)), lon, lat, alt,
                gm * love * 1e3, gs * love * 1e3, g0 * 1e3);
            return tidalAcceleration;
        }
    }
}